---
title: "SM for Brock et al. Progress in Physical Geography"
author: "James M.R. Brock, Finnbar Lee, John Wainwright, George L.W. Perry"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes:
 \usepackage{float}
 \floatplacement{figure}{H}
bibliography: references.bib
csl: global-ecology-and-biogeography.csl
editor_options:
  markdown:
    wrap: 72
nocite: |
  @wangMvabundPackageModelbased2012
---

## TO DO
 - It seems like you need to use different code depending on whether you plan on outputting to html or pdf, I have assumed we are outputting to pdf.
 - Ordination of veg data, in the description it states this is PA data, then there is an ordination with point size scaled by tawa abundance?
-   L 271-272 doesn't make sense? "below we do both with row sums as proportions of matrix sum as weights"
-   Add captions to some of the last figures fig 20+
-   Do we need any interpretation of resampled nMDS figures at all?
-   MEM?
-   Could use coenoflex for trajectory or JW's student?
-   Pairwise adonis is a bit janky

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Commented R code for analyses described in Brock et al. PiPG Progress
reports. To knit this Rmarkdown file to pdf we have used `R 4.1.2`, RStudio, the `knitr` package and other associated packages. 

This document shows how to perform the analyses described in Brock et
al. largely using the data from Lee et al.
[-@leePreySelectivityOntogenetic2018] and Perry et al.
[-@perryVegetationPatternsTrajectories2010]. It is *not* a detailed
description of the methods themselves (for that see references in the
main document) but rather an example of how to conduct the sorts of
analyses mentioned in the article. Knitting it from scratch may take
some time - there are some analyses that may take *hours* (but these are
cached and so the knitting process will look for saved versions *before*
doing an analysis).

First we'll load some packages necessary for the wrangling,
visualisation, and analyses.

```{r loadLibraries, message = FALSE, results = "hide", warning = "hide"}
# load pacman package + install if missing - used to load/install
# multiple packages at once
if (!require("pacman")) install.packages("pacman")

# load packages + install any that are missing
# GP - I am having linking issues in nix with mvabund...

pacman::p_load(
  # package management
  devtools,
  # data wrangling packages
  tidyverse, broom, knitr, janitor,
  # multivariate analysis packages
  vegan, analogue, Rtsne, umap, ecotraj, coenoflex, indicspecies, BiodiversityR,
  # plotting packages
  ggfortify, patchwork, mdthemes)
```

```{r loadLibraries_2, message = FALSE, results = "hide", warning = "hide"}
# install packages from GitHub (not available on CRAN) -
# this will check, and only install if required
devtools::install_github("phytomosaic/ecole")       
devtools::install_github("phytomosaic/fitNMDS")
devtools::install_github("jfq3/ggordiplots")
devtools::install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
devtools::install_github("gavinsimpson/ggvegan")
```

```{r loadFunctions, message = FALSE, results = "hide", warning = "hide"}
# load newly installed packages from GitHub
pacman::p_load(
  # multivariate analysis packages
  ecole, fitNMDS, pairwiseAdonis,
  # plotting packages
  ggordiplots, ggvegan)

# load custom functions for plotting ordinations from vegan
source("./auxScripts/helperPlots.r")
```

# Load data

Load data we'll explore and do some re-organising. We need to be a bit
cautious because although base `R` and many multivariate analysis
packages (e.g., `vegan`) use row names, the `tidyverse` (tibbles) does
*not* as they don't confirm to tidy data. Need to be aware of this when
moving between the two.

The first dataset we will explore contains three files, i) stream
physiochemical (including riparian and catchment land use data) measures
from 29 sites across South Auckland, New Zealand. The sites span a
catchment-scale agricultural land use gradient, ranging from catchments with
little-to-no agriculture to relatively high levels of agricultural land use.
ii) freshwater invertebrate abundance data for 76 taxa across the 29 sites, 
and, iii) geographic coordinates of the 29 sites (WGS84). The original study [-@leePreySelectivityOntogenetic2018] explored how the diet of an invasive
fish (*Gambusia affinis*) changed as prey availability (invertebrates)
shifted, driven by agricultural land use in the catchment.

```{r loadLeeData}
# Load data and tidy up

# invert abundances
inverts <- read.csv(file = "./data/lee_2018_invertebrates.csv", row.names = 1)

# water physiochem at sites
chem <- read.csv(file = "./data/lee_2018_physicochemical.csv", row.names = 1)

# location data (WGS84 coords)
locations <- read.csv(file = "./data/lee_2018_coordinates.csv", row.names = 1)

# extract row names
invert_sites <- rownames(inverts)
chem_sites <- rownames(chem)

# standardise data
inverts_pa <- decostand(inverts, method = "pa")   # Presence-absence
inverts_l10 <- log10(inverts + 1)                 # log-10 transformed
inverts_hel <- decostand(inverts, method = "hel") # Hellinger transformed

# standardise column names
chem <- janitor::clean_names(chem)

# Subset of physiochemical data for hypothesis testing
chem_sub_hyp <- chem %>%
  select(do, temperature, velocity, proportion_silt, proportion_macrophyte,
         proportion_riparian_cover20, pasture, din)

# Binary vectors for proportion catchment native vegetation cover
native_cover <- chem$native > 0.2
```


The second dataset we will explore contains vegetation data from
Aotea/Great Barrier Island (New Zealand) from Perry et al. [-@perryVegetationPatternsTrajectories2010]. These data are collected
from geographic locations across Aotea using a plotless method of vegetation
survey. The geographic locations span a successional sequence from
post-fire recovery to mature secondary forest.

```{r loadAoteaData, warning = FALSE}
# Load the Aotea veg data
# vegan uses row names, but the tidyverse doesn't!
aotea <- read.csv(file = "./data/perry_2010_aotea.csv", row.names = 1)
aotea_pa <- decostand(aotea, method = "pa")            # convert to presence-absence
aotea_pa_nosing <- aotea_pa[, colSums(aotea_pa) > 1]   # PA without any singletons

# Make the site labels more useful
dfr <- data.frame(site = rownames(aotea_pa))
aotea_site <- separate(dfr, site, into = "code", "_") # ignore the warning
aotea_site$code <- str_sub(aotea_site$code, end = 2)
rm(dfr)
```

# Visualisation of the multivariate data

Now, some basic visualisation to highlight the nature of multivariate
(ecological) data using the Lee et al. 2018 data. This is **Figure X**
in the main document.

```{r visualiseMVA}
# First, lengthen the data to make it easier for ggplot
inverts_long <- inverts %>% 
  rownames_to_column(var = "site") %>%
  pivot_longer(cols = -site, names_to = "taxa", values_to = "abund")

# Histogram of number of sites each spp occurs at for Lee et al.
n_sites_iv <- data.frame(n = colSums(inverts > 0))

sites_hist_iv_gg <- ggplot(n_sites_iv) + 
  geom_histogram(aes(x = n), binwidth = 1) +
  labs(x = "No. of sites", y = "Frequency") +
  theme_minimal()

# A heat map of abundance for species x site for Lee et al. data
inverts_long$taxa_num <- as.numeric(factor(inverts_long$taxa,
                                           levels = unique(inverts_long$taxa)))

heat_iv_gg <- ggplot(inverts_long, aes(x = site, y = taxa_num)) +
  geom_raster(aes(fill = log10(abund)), show.legend = FALSE) +
  scale_fill_gradient(low="grey99", high="red") +
  labs(x = "Site", y = "Taxa") +
  theme_minimal() + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

# A dotplot to replicate that in Wang et al. 2012 Methods Ecol Evol
wang_iv <- data.frame(x = as.vector(as.matrix(inverts)), 
                        y = rep(1:ncol(inverts), each = nrow(inverts)), 
                        col = chem$native > 0.4)

dot_wang_iv_gg <- ggplot(data = wang_iv) + 
  geom_point(aes(x = log10(x+1), y = y, col = col),
             alpha = 0.8, size = 2, show.legend = FALSE) + 
  scale_color_brewer(type = "qual") +
  labs(y= "Taxa", x = "Abundance (log<sub>10</sub>[x+1])") +
  theme(axis.text.x=element_blank(), 
          axis.ticks.x=element_blank()) +
  md_theme_minimal()   # mdthemes lets us use markdown in graph notations

# combine plots
fig1 <- sites_hist_iv_gg + heat_iv_gg + dot_wang_iv_gg +
plot_annotation(tag_levels = "a")
```

```{r plotVis, echo = FALSE, fig.dim = c(8, 4), fig.align = "center", fig.cap = "Histogram of number of sites each taxa occurs at (a). Heat map of abundance for taxa x site, grey = not present, white = low abundances and red = high abundnces (b). Dotplot of taxa abundances, replicating that in Wang *et al* 2012 (c). All figures use the Lee et al. 2018 invertebrate data"}
fig1
```

Next, look at the mean-variance relationship in the two datasets - this
is of concern in tests of location and dispersion, and adequately
addressing it is central to model-based multivariate analysis
[@wartonModelbasedThinkingCommunity2015].

```{r meanVarReln}
# freshwater invert data
# calculate mean and variance
inverts_mv <- data.frame(mean = colMeans(inverts), 
                         var = apply(inverts , 2, var))

# plot
invert_mean_gg <- ggplot(data = inverts_mv) + 
  geom_point(aes(x = log10(mean), y = log10(var)), alpha = 0.8, size = 2) + 
  labs(y = "Variance (log<sub>10</sub> scale)",
       x = "Mean (log<sub>10</sub> scale)") +
  md_theme_bw() 

# Aotea vegetation data
# calculate mean and varaince
aotea_mv <- data.frame(mean = colMeans(aotea_pa), 
                       var = apply(aotea_pa , 2, var))

# plot
veg_mean_gg <- ggplot(data = aotea_mv) + 
  geom_point(aes(x = log10(mean), y = log10(var)), alpha = 0.8, size = 2) + 
  labs(y = "Variance (log<sub>10</sub> scale)",
       x = "Mean (log<sub>10</sub> scale)") +
  md_theme_bw() 

# combine plots
fig2 <- invert_mean_gg + veg_mean_gg +
  plot_annotation(tag_levels = "a")
```

```{r plotVis2, echo = FALSE, fig.dim = c(8, 4), fig.align = "center", fig.cap = "Mean-variance relationships for Lee et al. 2018 invertebrate (a) and Perry et al 2010 (b) vegetation data."}
fig2
```

# Unconstrained ordination

## Methods of multidimensional scaling

### Lee et al. invertebrate data

Having visualised the data, we can look at some ways to explore it using
multidimensional scaling as a means of dimensional reduction -- these
methods are available in the `vegan` package, which is extremely well
documented and support by a series of
[vignettes](https://cran.r-project.org/web/packages/vegan/). Here, we
are using the methods in an exploratory way, to generate hypotheses.

First, classical/metric MDS of the Lee et al.
[-@leePreySelectivityOntogenetic2018] invertebrate data. In `vegan` we can
do this either unweighted or weighted; below we do both with row sums as
proportions of matrix sum as weights. Also, because we use a
non-Euclidean distance metric there is a risk of negative eigenvalues,
so we use the `add` argument. Using `eig = TRUE` returns the eigenvalues
for us. Here, the weighted solution is strongly influence by a few sites
with much higher abundance than others (e.g., F16 and F01).

```{r pcoaInvert}
# Non-weighted using the Bray_Curtis
pcoa_iv <- wcmdscale(d = vegdist(inverts), eig = TRUE, add = "lingoes")

# get the weights (row sums)
wgt_iv <- iv <- rowSums(inverts)/sum(inverts)

 # Weighted
pcoa_wgt_iv <- wcmdscale(d = vegdist(inverts), w = wgt_iv, eig = TRUE, add = "lingoes")
```

```{r pcoaVisualise}
# Get the coordinates (using vegan::scores)
pcoa_scores <- data.frame(scores(pcoa_iv)[,1:2],
                          scores(pcoa_wgt_iv)[,1:2],
                          site = rownames(inverts),
                          w = wgt_iv) %>%
  rename(Dim1_wgt = Dim1.1, Dim2_wgt = Dim2.1)

# Get the eigenvalues and their proportional value
pcoa_eig <- data.frame(eig = pcoa_iv$eig[1:10], 
                       expl = round(pcoa_iv$eig[1:10] /
                                      sum(pcoa_iv$eig[1:10]) * 100, 2))

pcoa_wgt_eig <- data.frame(eig = pcoa_wgt_iv$eig[1:10], 
                           expl = round(pcoa_wgt_iv$eig[1:10] /
                                          sum(pcoa_wgt_iv$eig[1:10]) * 100, 2))

# Make some axis labels
xl <- paste("Dimension 1 (",pcoa_eig$expl[1], "%)", sep = "")
yl <- paste("Dimension 2 (", pcoa_eig$expl[2], "%)", sep = "")

xl_w <- paste("Dimension 1 (",pcoa_wgt_eig$expl[1], "%)", sep = "")
yl_w <- paste("Dimension 2 (", pcoa_wgt_eig$expl[2], "%)", sep = "")

## unweighted plot
pcoa_gg <- ggplot(pcoa_scores) + 
  geom_text(aes(x = Dim1, y = Dim2, label = site), size = 3) + 
  labs(x = xl,
       y = yl) + 
  coord_equal() + 
  theme_bw()

# eigenvalues plot
pcoa_eig_gg <- ggplot(pcoa_eig) + 
  geom_bar(aes(x = as.factor(1:10), y = expl),
           stat = "identity") + 
  labs(x = "Dimension",
       y = "Eigenvalue (% total)") +
  theme_bw()

## weighted plot
pcoa_wgt_gg <- ggplot(pcoa_scores) + 
  geom_text(aes(x = Dim1_wgt, y = Dim2_wgt, label = site, size = w)) + 
  scale_size_continuous(range  = c(1, 4)) +
  labs(x = xl_w,
       y = yl_w,
       size = "weight") + 
  coord_equal() + 
  theme_bw()

# eigenvalues plot
pcoa_eig_wgt_gg <- ggplot(pcoa_wgt_eig) + 
  geom_bar(aes(x = as.factor(1:10), y = expl), stat = "identity") + 
  labs(x = "Dimension",
       y = "Eigenvalue (% total)") +
  theme_bw()

# gather plots
fig3 <- (pcoa_gg + pcoa_eig_gg + pcoa_wgt_gg + pcoa_eig_wgt_gg) + 
  plot_layout(widths = c(1, 1)) + 
  plot_annotation(tag_levels = 'a') & 
  theme(legend.position = 'bottom')

```

```{r plotVis3, echo = FALSE, fig.align = "center", fig.dim = c(10, 8), fig.cap = "Unweighted metric MDS (a) and associated eigenvalues (b), weighted metric MDS (c) and associated eigenvalues (d) for Lee et al. 2018 Invertebrate data"}
fig3
```

Second, look at non-metric multidimensional scaling. Remember that
although nMDS and PCOA are both called 'multidimensional scaling' they
are quite different in that nMDS works on ranks and is based on a
stochastic (non-analytic) algorithm. We'll start with the Lee et al.
invertebrate data showing the nMDS and then fitting environmental
vectors on it (commands `vegan::metaMDS` and `vegan::envfit`,
respectively).

```{r nmdsInvert, echo = T, results = 'hide'}
# nMDS of the Lee et al. invertebrate data

# Bray-curtis distance matrix
invert_dist <- vegdist(inverts)

# Turn off automatic rescaling. Trace controls output verbosity
invert_mds <- metaMDS(invert_dist, autotransform = FALSE, trace = 1)

# Make the plots (using custom plot.mds.gg function from ./auxScripts/helperPlots.r)
iv_mds_gg <- plot.mds.gg(invert_mds, txt.x = -0.35,
                         txt.y = -0.35,labels = TRUE,
                         msl = 0.25)

# nMDS with points scaled in size by abundance of _Physa_
wgt <- inverts$Physa / 10
iv_bubble_gg <- plot.mds.bubble.gg(invert_mds, weights = wgt, lbl = "Physa abundance / 10")

# Fit the chemical data as environmental vectors (envfit) and plot
iv_chem_fit <- envfit(invert_mds, chem_sub_hyp)
iv_fit_gg <- plot.envfit.gg(invert_mds,
                            iv_chem_fit,
                            p.max = .2,
                            clusters = native_cover,
                            lbl = "Native veg > 20%")

# Or we could synthesis all the chem data with a PCA and fit those axes
chem_pca <- princomp(chem, cor = TRUE) 
chem_pca_scores <- scores(chem_pca)
iv_pca_fit <- envfit(invert_mds, chem_pca_scores[,1:8])

iv_fitpca_gg <- plot.envfit.gg(invert_mds,
                               iv_pca_fit,
                               p.max = .1,
                               clusters = native_cover,
                               lbl = "Native veg > 20%")

# gather plots
fig4 <- (iv_mds_gg + iv_bubble_gg + iv_fit_gg + iv_fitpca_gg) +
  plot_annotation(tag_levels = "a") + 
  plot_layout(ncol = 2, guides ="collect") & 
  theme(legend.position = "bottom")
```

Visually, there are no strong and obvious clusters in ordination space
suggesting the sites lie along an environmental gradient (rather than
discrete environmental conditions). PCA shows that there is a dominant
axis relating to land-use (proportion forest, etc.) and a second axis
relating to stream conditions (e.g. width and flow velocity) and water
quality. The vectors suggest that Dissolved organic nitrogen (DIN) and
water temperature are the most important environmental vectors (p \<
0.05), and the PCA scores components 2, 5 and 6 are important (but only
DIN p \< 0.05).

```{r plotnMDSLee, echo = FALSE, fig.cap = "nMDS of invertebrate data (a), with point size scale by Physa (genus of snails) abundance (b), and physiocemical data fit as environmental vectors (c), and with environmetal vectors fit using PCA axes generated using all physiochemical variables (d).", fig.dim = c(8, 8)}
fig4
```

One issue with fitting vectors is that they may not depict non-linear
relationships adequately (although they have the benefit of allowing
multiple variables to be seen). An option is to fit a surface (e.g. via
a spline or general additive model [GAM]) instead. Here, we fit DIN and
the first component of the PCA to the invertebrate nMDS. As with any
surface fitting exercise it is important to evaluate the effects of
different parametrisations (e.g., the knots used in the GAM) via the
underlying diagnostics.

```{r message = FALSE, warning = FALSE, fig.show='hide'}
# Ordisurf using DIN and PCA components and knots = 5 or 10
din_surf_k5 <- ordisurf(x = invert_mds, y = chem$din, knots = 5, plot = FALSE)
pca_surf_k5 <- ordisurf(x = invert_mds, y = chem_pca_scores[,1], knots = 5, plot = FALSE)
din_surf_k10 <- ordisurf(x = invert_mds, y = chem$din, knots = 10, plot = FALSE)
pca_surf_k10 <- ordisurf(x = invert_mds, y = chem_pca_scores[,1], knots = 10, plot = FALSE)

# plot surfaces using ggplot
plot_din_k5 <- plot.ordsurf.gg(invert_mds, din_surf_k5, lbl = "DIN", knts = 5, comb = T)
plot_pca_k5 <- plot.ordsurf.gg(invert_mds, pca_surf_k5, lbl = "PCA comp", knts = 5)
plot_din_k10 <- plot.ordsurf.gg(invert_mds, din_surf_k10, lbl = "DIN", knts = 10, comb = T)
plot_pca_k10 <- plot.ordsurf.gg(invert_mds, pca_surf_k10, lbl = "PCA comp", knts = 10)

fig5 <- (plot_din_k5 + plot_pca_k5) / (plot_din_k10 + plot_pca_k10) +
    plot_annotation(tag_levels = "a") + 
    plot_layout(guides = "collect")  & 
    theme(legend.position = 'bottom')
```

```{r invertSurface, fig.cap = "Dissolved organic nitrogen (DIN) fit as a surface to the nMDS with different paramertisations of *k* (a, c). PCA component 1 fit as a surface to the nMDS with different paramertisations of *k* (b, d).", fig.dim = c(8, 8), message = FALSE, warning = FALSE, echo = FALSE}
fig5
```

### Perry et al. vegetation data

Now we'll do an nMDS of the Aotea vegetation data. Unlike the Lee et al.
invertebrate data, this information is presence-absence only, and covers
many more sites and species (`r nrow(aotea)` x `r ncol(aotea)`).
Although it may seem obvious that presence-absence is less informative
than abundance data, this is context-dependent. Wilson
[-@bastowwilsonSpeciesPresenceAbsence2012] suggests that abundance data
are more informative that presence-absence data (in ordinations) only
where small extents are covered, the vegetation is reasonably
homogeneous, and the abundance information is high-quality. This example
may have some issues with finding a convergent solution - check the
`vegan` help for details.

```{r mdsAotea, echo = FALSE, message = FALSE, results = 'hide'}
# nMDS of the Aotea veg data (presence-absence)
aotea_dist <- vegdist(aotea_pa)

# This code looks for a saved version of the nMDS and uses it if available (assumed stored in a folder called rds) - this speeds the analysis, which can be slow.
if (file.exists("./rds/aotea_mds.rds")) { 
  aotea_mds <- readRDS("./rds/aotea_mds.rds") } else {
  n_cores <- parallel::detectCores() - 1  
  aotea_mds <- metaMDS(aotea_dist, autotransform = FALSE, trace = 1,
                       parallel = n_cores)
  aotea_mds_3d <- metaMDS(aotea_dist, autotransform = FALSE,
                          try = 100, trace = 1, k = 3,
                          parallel = n_cores)
  
  saveRDS(aotea_mds, "./rds/aotea_mds.rds") 
}

# plot Shepperd plot
aotea_shep_gg <- plot.shepp.gg(aotea_dist, aotea_mds)

# plot ordination
aotea_mds_gg <- plot.mds.gg(aotea_mds, txt.x = -0.6, txt.y = -0.35,
                            clusters = factor(aotea_site$code)) +
                theme(legend.position = "bottom")

# gather plots
fig6 <- (aotea_shep_gg + aotea_mds_gg) + 
  plot_annotation(tag_levels = "a")

# nMDS with points scaled to the abundance of the late successional tree, Beilschmiedia tawa
fig7 <- plot.mds.bubble.gg(aotea_mds, weights = aotea$Beitaw)

```

```{r plotnMDSAotea1, echo = FALSE, fig.dim = c(8, 6), fig.cap = "Shepperd plot (a), nMDS ordination (b) of vegetation data."}
fig6
```

```{r plotnMDSAotea2, echo = FALSE, fig.cap = "nMDS ordination of of vegetation data with point size scaled by the abundance of the late successional tree, *Beilschmiedia tawa*"}
fig7
```

## Principle response curves

Principle response curves seek to fit a smooth curve though some high
dimensional space. They are probably most appropriate where there is a
single dominant gradient (in time or space)
[@deathPrincipalCurvesNew1999;
@simpsonStatisticalLearningPalaeolimnology2012]. Here, we will apply it
to the Lee et al. data, which is underpinned by a strong gradient in
land-use, using the implementation in `analogue::prcurve`. The initial
configuration can be quite important (see De'ath
[-@deathPrincipalCurvesNew1999]), so here we use the first axis of a
correspondence analysis, with a GAM, and allow the complexity of the
smoother to vary across species. We can show the fit of the curve at
each iteration by setting `plotit = TRUE`.

```{r prCurves}

# Fit PRC here with the complexity fixed across all species (vary)
# The method here specifies the starting conditions (first axis of a method)
# Here we use a GAM as the smoother (slower than spline)
inverts_pc <- prcurve(inverts_l10, method = "ca", trace = TRUE,
                      vary = TRUE, smoother = smoothGAM,
                      penalty = 1.4)
inverts_pc

fig8 <- plot.prcurve.gg(inverts_pc) +
  ggtitle("Final solution for principle curve")
```

```{r echo = FALSE, fig.cap = "Principal response curve for the freshwater invertebrate dataset.", warning = FALSE}
fig8
```

We can see that the curve captures 43% of the variance but (say compared
to a PCA) at the cost of a much more complex model. It is also possible
to look at individual taxa response along the gradient identified in the
principle curve. The command in analogue is `sppResponse`. Here, we have
plotted the subset of taxa occurring at at least 17 (60%) of survey
sites. Visually, we can see some taxa sorting along the gradient
identified in the PC; some taxa respond curvilinearly (e.g.,
Chironomidae) but others show a threshold-type effect (e.g., Amphipods).

```{r speciesPCResponses}
# taxa responses
invert_responses <- sppResponse(inverts_pc)

# subset common taxa (> 60% sites)
focal_spp <- chooseTaxa(inverts_l10, n.occ = 17, value = FALSE)

# plot
fig9 <- plot.sppResponse.gg(invert_responses, focal_spp = focal_spp)
```

```{r echo = FALSE, fig.cap = "Principal response curve taxa responses for the freshwater invertebrate dataset."}
fig9
```



## Non-linear mapping: tsne and UMAP

We will demonstrate two methods of non-linear mapping: tSNE and UMAP. As
discussed in the main text these are different from the other methods
we've discussed in the way they seek to balance local and global
structure. This also means that we need to be careful in interpreting
the size of clusters and so forth. For tSNE and UMAP we will use the
`Rtsne` and `umap` packages, respectively.

### tsne

For tSNE the key hyperparameter is *perplexity*, which controls the
balance between local and global structure (by, in essence, determining
each point's neighbourhood). The Rtsne help recommends that
$3 * perpexity < nrow - 1$ (the default is 30, but that is too high for
the Lee et al. invertebrate data).

```{r ivtsne}
# Try a couple of perplexity values, low theta for more accurate but slower
invert_tsne_p3 <- Rtsne(inverts, perplexity = 3, theta = 0.0)
invert_tsne_p6 <- Rtsne(inverts, perplexity = 6, theta = 0.0)

# Can supply a distance matrix if we wish non-Euclidean distances between sites
invert_dist <- vegdist(inverts, method = "bray")
invert_tsne_bc_p3 <- Rtsne(invert_dist, perplexity = 3, is_distance = TRUE)
invert_tsne_bc_p6 <- Rtsne(invert_dist, perplexity = 6, is_distance = TRUE)
```

And plot them; clearly, and perhaps unsurprisingly, the choice of
distance metric is very important. Likewise, the perplexity value
influences the way the sites are arranged, especially for the
Bray-Curtis metric.

```{r plotivTSNE}

tsne3_gg <- plot.nonlin.gg(invert_tsne_p3, site_labels = invert_sites, labels = TRUE)
tsne6_gg <- plot.nonlin.gg(invert_tsne_p6, site_labels = invert_sites, labels = TRUE)
tsned3_gg <- plot.nonlin.gg(invert_tsne_bc_p3, site_labels = invert_sites, labels = TRUE)
tsned6_gg <- plot.nonlin.gg(invert_tsne_bc_p6, site_labels = invert_sites, labels = TRUE)

fig10 <- (tsne3_gg + tsne6_gg + tsned3_gg + tsned6_gg) + 
  plot_annotation(tag_levels = "a") +
   plot_layout(ncol = 2, nrow = 2, widths = c(1,1), heights = c(1,1)) # force even layout
```

```{r fig.cap = "tSNE for the Lee et al. data with perplecity = 3 and a Euclidean distance matrix (a), perplecity = 6 and a Euclidean distance matrix (b), perplecity = 3 and a Bray-Curtis distance matrix (c) and, perplecity = 6 and a Bray-Curtis distance matrix (a)", echo = FALSE, fig.dim = c(8, 8), warning = FALSE}
fig10
```

We can now apply the tSNE to the much larger Aotea vegetation data;
again, assessing two different perplexities and with/without the
Bray-Curtis measure.

```{r aoteatsne}
# Rtsne will not work if there are duplicated rows (i.e. identical sites)
# so we need to remove them
undup <- !duplicated(aotea_pa)
aotea_pa_nodup <- aotea_pa[undup,]
aotea_sites_nd <- aotea_site$code[undup]

# Try a couple of perplexity values, low theta for more accurate but slower
aotea_tsne_p25 <- Rtsne(aotea_pa_nodup, perplexity = 25, theta = 0.0)
aotea_tsne_p50 <- Rtsne(aotea_pa_nodup, perplexity = 50, theta = 0.0)

# Can suppl a distance matrix if we wish non-Euclidean distances between sites
aotea_dist <- vegdist(aotea_pa_nodup, method = "bray")
aotea_tsne_bc_p25 <- Rtsne(aotea_dist, perplexity = 25, theta = 0.0, is_distance = TRUE)
aotea_tsne_bc_p50 <- Rtsne(aotea_dist, perplexity = 50, theta = 0.0, is_distance = TRUE)
```

And plot them. Here the differences between the two distance metrics are
less clear. The algorithm tends to cluster the geographic locations
together and order them in a successional sequence (from 'AW' to 'Te')
while showing also that they form a continuum based on their
composition.

```{r plotAoteaTSNE}
lb <- 1:nrow(aotea_pa_nodup)

tsne_ao_p25_gg <- plot.nonlin.gg(aotea_tsne_p25, clusters = aotea_sites_nd)
tsne_ao_p50_gg <- plot.nonlin.gg(aotea_tsne_p50, clusters = aotea_sites_nd)
tsne_ao_d_p25_gg <- plot.nonlin.gg(aotea_tsne_bc_p25, clusters = aotea_sites_nd)
tsne_ao_d_p50_gg <- plot.nonlin.gg(aotea_tsne_bc_p50, clusters = aotea_sites_nd)

fig11 <- (tsne_ao_p25_gg + tsne_ao_p50_gg + tsne_ao_d_p25_gg + tsne_ao_d_p50_gg) +
  plot_layout(guides = "collect", ncol = 2, nrow = 2, widths = c(1,1), heights = c(1,1)) &
  theme(legend.position = "bottom")

```


```{r fig.cap = "tSNE for the Perry et al. data with perplecity = 25 and a Euclidean distance matrix (a), perplecity = 50 and a Euclidean distance matrix (b), perplecity = 25 and a Bray-Curtis distance matrix (c) and, perplecity = 50 and a Bray-Curtis distance matrix (a)", echo = FALSE, fig.dim = c(8, 8), warning = FALSE}
fig11
```


### UMAP

We can now look at the UMAP algorithm (just for the Aotea data for
space). The implementation in the `umap` library uses a special object
class for the many possible configuration options, so we can tune the
hyper-parameters in detail (including some distance metrics, there is
more control of this available in the Python implementation).

```{r umapAotea}
set.seed(8736317)
# check the default options
umap.defaults

# Run a umap using the default settings
aotea_umap <- umap(aotea_pa)

# What if we change the number of neighbours evaluated
umap_hparam <- umap.defaults
umap_hparam$n_neighbors <-  30

aotea_umap_nn30 <- umap(aotea_pa, config = umap_hparam)

# Or the minimum distance between points (the packing of similar locations)
umap_hparam <- umap.defaults
umap_hparam$n_neighbors <-  15
umap_hparam$min_dist <- 0.05

aotea_umap_md05 <- umap(aotea_pa, config = umap_hparam)


```

The final configuration is reasonably robust to the hyper-parameter
values (location clustering is similar and the successional sequence
evident).

```{r plotUmapAotea}
aotea_umap_gg  <- plot.nonlin.gg(aotea_umap, labels = FALSE, clusters = aotea_site$code)
aotea_umap_nn30_gg  <- plot.nonlin.gg(aotea_umap_nn30, labels = FALSE, clusters = aotea_site$code)
aotea_umap_md05_gg <- plot.nonlin.gg(aotea_umap_md05, labels = FALSE, clusters = aotea_site$code)


fig12 <- (aotea_umap_gg + aotea_umap_nn30_gg + aotea_umap_md05_gg) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom")
```

```{r fig.cap = "UMAP for the Perry et al. data with different hyper-parameter values (see code block above).", fig.dim = c(8, 4), echo = FALSE}
fig12
```


# Constrained ordination

Now, we can move onto some methods of constrained ordination. First, a
look at the 'tikus' dataset (measures of coral reef communities over
time) to compare an unconstrained and a constrained (by time) ordination
(data available in the `mvabund` package in R). Here, a distance-based
redundancy analysis (`vegan::dbrda`) with an nMDS is presented. We will
log-transform the data. This example is presented in detail in ver Braak
and Šmilauer [-@terbraakTopicsConstrainedUnconstrained2015]. Note that
for the `metaMDS` we have increased the number of runs (*try*) and
iterations (*maxit*) to help ensure convergence on an optimal solution.

```{r tikusExample, echo = T, results = 'hide'}

# load data - this as per the mvabund package
# https://github.com/aliceyiwang/mvabund/blob/master/data/tikus.RData
load("./data/tikus.RData")

# log transform
tikus_log <- log(tikus$abund + 1)
tikus_survey <- tikus$x$time

# Unconstrained ordination of the Tikus coral reef data
# nMDS - increased try and maxit for convergence
tikus_nmds <- metaMDS(tikus_log, autotransform = FALSE,
                      wascores = FALSE,
                      try = 100, maxit = 500, trace = 1)

# plot
tik_mds_gg <- ggplot(data = as.data.frame(scores(tikus_nmds))) +
  geom_point(aes(NMDS1, NMDS2, col = as.factor(tikus$x$time)), size = 3) +
  scale_color_brewer(name = "Year", palette = "PuRd") +
  coord_equal() +
  theme_minimal()

# Constrained (by time) ordination of the Tikus coral reef data
# Note use of formula notation
tikus_rd <- dbrda(tikus_log ~ tikus_survey, distance = "bray")
tikus_rd_scores <- data.frame(scores(tikus_rd)$sites)

#plot
tik_rd_gg <- ggplot(data = tikus_rd_scores) + 
  geom_point(aes(dbRDA1, dbRDA2, col = as.factor(tikus_survey)), size = 3) +
  scale_color_brewer(name = "Year", palette = "PuRd") +
  coord_equal() +
  theme_minimal()

fig13 <- (tik_mds_gg + tik_rd_gg) + 
    plot_annotation(tag_levels = "a") +
    plot_layout(guides = "collect", widths = c(1, 1)) &
    theme(legend.position = "bottom")
```

```{r plotTikusExample, echo = FALSE, fig.cap = "", fig.dim = c(8, 8), fig.cap = "Uncontrained ordination of coral reef communities (a), and constrained (by time) ordination (b)."}
fig13
```


## RDA and CCA

A basic form of constrained analysis is redundancy analysis (RDA). We
can do this using the command `vegan::rda`; note that if we do an RDA
without any environmental variables we will have a PCA. Usually we will
have two matrices; one describing the community at each site and the
other the environmental variables (which constrain the ordination). The
RDA in vegan allows use of a third matrix that can be partialled out
(the 'conditioning matrix'). We will do an RDA on a Hellinger
transformed version of the Lee et al. data (transformed following the
advice of Legendre & Gallagher
[-@legendreEcologicallyMeaningfulTransformations2001]).

```{r rdaInvert}
# RDA on subset of env data
invert_rda <- rda(inverts_hel ~ ., data = chem_sub_hyp) 

# adjusted r2 (via the vegan package)
invert_rda_r2 <- round(RsquareAdj(invert_rda)$adj.r.squared, 3) 

# Plot using autoplot in ggvegan (as an example of the function)  
fig14 <- autoplot(invert_rda, layers = c("biplot", "sites"), geom = "text") +
  theme_minimal() + 
  theme(legend.position = "none")
```

```{r plotRDAInvert, echo = FALSE, fig.cap = "Constrained redundancy analysis (RDA) for freshwater invertebrate and physiochemical data.", fig.dim = c(8,4)}
fig14
```

Now a canonical correspondence analysis (CCA) using the `vegan::cca`
command. We'll build two models on log~10~ transformed abundance data,
one saturated and one using a subset of environmental predictors.

```{r ccaInvert}
# saturated
invert_cca_all <- cca(inverts_l10, chem)

# subset of predictors
invert_cca_red <- cca(inverts_l10, chem_sub_hyp)
```

We can plot the saturated and reduced model and compare them.

```{r plot-invertCCA}

# Plot them - autoplot here is from ggvegan
invert_cca_all_gg <- autoplot(invert_cca_all, layers = c("biplot","sites"),
                              geom = "text") + 
  theme_bw() + 
  theme(legend.position = "none")

invert_cca_red_gg <- autoplot(invert_cca_red, layers = c("biplot","sites"),
                              geom = "text") + 
  theme_bw() + 
  theme_bw() +
  theme(legend.position = "none")

# combine plots
fig15 <- invert_cca_all_gg + invert_cca_red_gg + 
  plot_annotation(tag_levels = "a")
```

```{r fig.cap = "canonical correspondence analysis of freshwater invertebrate and environemntal data using all (a) and a subset (b) of environemtnal predictors.", fig.dim = c(8, 6), echo = FALSE}
fig15
```

## Distance-based RDA

dbRDA is similar to RDA but is designed to support a broader range of
dissimilarity metrics (including some of those frequently used by
community ecologists). Note that in vegan there are two versions,
`capscale` (following Legendre and Anderson
[-@legendreDistancebasedRedundancyAnalysis1999]) and `dbrda` (following
McArdle & Anderson [-@mcardleFittingMultivariateModels2001]). These
differ in some implementation details (read the help!). Here we will use
`capscale` to look at the Lee et al. invertebrate data.

```{r dbRDA}

# run analysis
invert_dbrda <- capscale(inverts ~ ., chem_sub_hyp, dist="bray")

# plot
fig16 <- autoplot(invert_dbrda, layers = c('sites', 'biplot')) +
  theme_bw() + 
  theme(legend.position = 'none')
```

```{r fig.cap = "dbRDA of freshwater invertebrate and enviromental data.", fig.dim = c(6,6), echo = FALSE}
fig16
```

## Variable selection and axis selection

For constrained ordinations it is possible to use various selection
methods to assess the importance of individual variables and the
significance of the axes. This can be done using forward, backward or
stepwise model selection based on R^2^ or AIC; each of these come with
*caveats*., For example, the vegan help for `ordistep` pithily notes,
"... constrained ordination methods do not have AIC, and therefore the
step may not be trusted.". It is important to understand the various
options available when conducting these (and any) analysis.

```{r dbrdaVarSel}
# full model
full_mod_dbrda <- capscale(inverts_hel ~ ., data = chem_sub_hyp, dist = "bray")

# intercept-only model
null_mod_dbrda <- capscale(inverts_hel ~ 1, data = chem_sub_hyp, dist = "bray")

# variable selection
sel_mod_dbrda <- ordistep(null_mod_dbrda, 
                          scope = formula(full_mod_dbrda), 
                          direction = "both", 
                          permutations = how(nperm = 499), trace = FALSE ) 

# compare models
anova(sel_mod_dbrda)

# get adj R squared
full_mod_dbrda_r2 <- round(RsquareAdj(full_mod_dbrda)$adj.r.squared, 3)
sel_mod_dbrda_r2 <- round(RsquareAdj(sel_mod_dbrda)$adj.r.squared, 3)

# plot
dbrda_full_gg <- autoplot(full_mod_dbrda, layers = c("sites", "biplot"), geom = "text") +
  theme_minimal() + 
  theme(legend.position = 'none')

dbrda_sel_gg <- autoplot(sel_mod_dbrda, layers = c("sites", "biplot"), geom = "text") +
  theme_minimal() + 
  theme(legend.position = 'none')

# combine plots
fig17 <- dbrda_full_gg + dbrda_sel_gg + 
  plot_layout(guides = "collect")

```

```{r plotFullSel, fig.cap = paste("dbRDA including all hypothesised predictors, Adjusted R^2^ = ", full_mod_dbrda_r2, " (a) ", "and a subset based on model selection, Adjusted R^2^ = ", sel_mod_dbrda_r2, " (b).", sep = ""), echo = FALSE}
fig17
```

In a similar vein, we can look at the significance of each variable or
axis (again, using `vegan::anova.cca`). This command uses a
permutation-based approach (see Legendre et al.
[-@legendreTestingSignificanceCanonical2011]). As an example, we will
use RDA on the Hellinger-transformed invertebrate data.

```{r axisSigRDA}
# Model with all explanatory variables
full_mod <- rda(inverts_hel ~ ., chem_sub_hyp)

# test for the overall model
mod_aov <- anova(full_mod)

# can also do marginal tests - see vegan help
term_aov <- anova(full_mod, by = "term")
axis_aov <- anova(full_mod, by = "axis")

mod_aov  # Model is significant
term_aov # look for significant terms  
axis_aov # and axes
```


# Recent advances

## Resampling assessment of ordinations

To demonstrate the method, we will build resampled NMDS for the Lee et
al. invertebrate data and Perry et al. vegetation data based on 99 *n*
resamplings using 80% of the total data. The bootstrapping allows us to
look at the confidence we might have in, for example, differences
between individuals or groups of sites due to sampling variation.

```{r resampleMDS}

# Define number of simulations to do - slow for large data but could parallelise!
# We'll use fitNDMS::resamp_ndms to do this.  BS is the bootstrap size and
# B the no., of sims. Underneath it is using vegan::metaMDS

nsims_iv <- 199 
nsims_aotea <- 5  # need more for analysis but this is **slow**! 

# Because this is slow we'll cache the op in a directory called 'rds'
  if (file.exists("./rds/invert_resamp.rds")) {
      b_iv <- readRDS("./rds/invert_resamp.rds") } else { 
      set.seed(1767283)    # set seed for reproducibility
      b_iv <- resamp_nmds(inverts, BS = nrow(inverts) * 0.8, B = nsims_iv, k = 2)
      saveRDS(b_iv, "./rds/invert_resamp.rds") 
  }
  
  # as per above need to check convergence...
  if (file.exists("./rds/aotea_resamp.rds")) { 
      b_aotea <- readRDS("./rds/aotea_resamp.rds") } else { 
      set.seed(4337659)
      b_aotea <- resamp_nmds(aotea_pa, BS = nrow(aotea_pa) * 0.8, B = nsims_aotea, k = 2)
      saveRDS(b_aotea, "./rds/aotea_resamp.rds") 
      }

# Code here will trigger some warnings re expected pieces and coercion - can ignore
# Note that the number of times a site is sampled will not necessarily equal n_sims 
# It is c. 0.8 x sims

# tidy data
b_iv_dfr <- data.frame(b_iv$points) %>% 
    rownames_to_column(var = 'site') %>% 
    arrange(site) %>% 
    separate(site, into = c('site', 'rep'), sep = "\\.") %>% 
    mutate(rep = as.numeric(rep)) %>% 
    mutate(rep = if_else(is.na(rep), 1 , as.numeric(rep) + 1))

############################# TO DO - this might need checking #################
b_aotea_dfr <- data.frame(b_aotea$points) %>% 
    rownames_to_column(var = 'pcq.site') %>% 
    arrange(pcq.site) %>% 
    separate(pcq.site, into = c('pcq_point', 'rep'), sep = "\\.") %>%
    mutate(site = gsub("_.*","", pcq_point)) %>%
    mutate(rep = if_else(is.na(rep), 1 , as.numeric(rep) + 1))
  
# plot
resamp_iv_gg <- plot.resamp(b_iv_dfr) 
resamp_aotea_gg <- plot.resamp(b_aotea_dfr, legend = TRUE)

resamp_iv_stress_gg <- ggplot(data = data.frame(s = b_iv$stresses)) +
  geom_histogram(aes(s), bins = 20) + labs(x = 'Stress', y = 'Frequency') +
  theme_minimal()

resamp_aotea_stress_gg <- ggplot(data = data.frame(s = b_aotea$stresses)) + 
  geom_histogram(aes(s), bins = 10) + 
  labs(x = 'Stress', y = 'Frequency') + 
  theme_minimal()

fig18 <- (resamp_iv_gg + resamp_iv_stress_gg) / (resamp_aotea_gg + resamp_aotea_stress_gg) + 
  plot_layout(widths = c(2, 1)) +
  plot_annotation(tag_level = "a") +
  plot_layout(guides = "collect") & 
  theme(legend.position = 'bottom')
```

## Do we need any interpretation of the figures here??
```{r fig.cap = "Bootsrapped nMDS of the Lee et al. invertebrate data (a), and the distribution of associated stress scores (b). Bootsrapped nMDS of the Perry et al. vegetation data (c), and the distribution of associated stress scores (d).", fig.dim = c(6,6), echo = FALSE}
fig18
```


## Trajectory analysis

Neither the invertebrate nor vegetation data we have used are suitable
for trajectory analysis. Thus, we will use some simple simulated data
(via the `coenoflex` package) to illustrate its use. To conduct trajectory
analysis in `R` you can use the `ecotraj` package - it is support by an
excellent
[vignette](https://cran.r-project.org/web/packages/ecotraj/vignettes/IntroductionETA.html)
and some sample data.

```{r simCommunity, warning = FALSE, message = FALSE}
set.seed (5963277)

# make the community - see the coenoflex help for full details
# the veg element of this is the site-species matrix
traj_comm <- coenoflex(numgrd = 1,
          numplt = 20,
          numsp = 80,
          grdtyp = "e",
          grdlen = 100,
          width = 30,
          variab = 50,
          grdprd = 0,
          alphad = 0.7,
          pdist = "G",
          sdist = "r",
          skew = 3.0,
          aacorr = 0,
          cmpasy = 1.5,
          maxtot = 100,
          noise = 35,
          slack = 0.3,
          autlin = "irm(1)")

# plot
sim_grad_gg <- plot.coeno.gg(traj_comm)$grad_plot
sim_rich_gg <- plot.coeno.rich.gg(traj_comm)$rich_plot

fig19 <- sim_grad_gg + sim_rich_gg +
    plot_annotation(tag_level = "a")
```

```{r echo = FALSE, fig.cap = "Simulated community response to environmental gradiet (a), species richness along the simulated gradient (b).", fig.dim = c(8, 4), warning = FALSE, message = FALSE}
fig19
```

We now have one simulated community so we can look at its trajectory
through ordination space (here with an nMDS).

```{r mdsTRaj, message = FALSE, warning = FALSE, fig.dim = c(8, 4), results = 'hide', fig.cap = "Trajectory of a simulated community through ordination space."}

# Description of sites and surveys
sites <- rep(1, 20)
surveys <- 1:20
  
# Locations in ordination space for the data
traj_mds <- metaMDS(traj_comm$veg, distance = "bray", autotransform = FALSE)
traj_xy <- scores(traj_mds)

# Plot the trajectory
plot.mds.gg(traj_mds, labels = TRUE, txt.x = -2.5, txt.y = 1)
```

```{r, fig.cap = "Trajectory of a simulated community through ordination space.", fig.dim = c(8, 4)}
trajectoryPlot(traj_xy, sites, surveys, lwd = 2)
```

## Multiple sites?

## Tests of location and dispersion

Often when conducting an unconstrained ordination we have information
about *a priori* groups or explanatory variables for each site. We
emphasise the *a priori* as there is a risk of circularity in using
ordination to identify groups and then assessing whether they differ
from each other. There are two questions we might ask: (i) do these
groups differ in their location, and (ii) do the groups differ in their
scatter ('dispersion'). The first question would allow us to assess
whether there have been shifts in community structure under different
management regimes, for example; the second, is relevant where there may
not be a change but a site is winnowed out to a subset of some other
reference community (e.g. under invasion). Most of these methods are
permutation-based (meaning we can use parallelisation to speed thigns
uo) and operate on the dissimilarity matrix rather than an ordination.
We'll use the Aotea data to demonstrate these methods as we have groups
(geographic locations).

```{r aoteaDistPermutest, warning = FALSE, message = FALSE}

 # reduce if you want to speed up!
n_perm <- 499

# cores for parallelisation (set to 1 for none)
n_cores <- parallel::detectCores() - 1

aotea_dist <- vegdist(aotea_pa, method = "bray")

# ANOSIM on 'site
aotea_anosim <-anosim(aotea_dist, aotea_site$code,
                      permutations = n_perm,
                      parallel = n_cores)  

# PERMANOVA on 'site'
aotea_adonis <- adonis2(aotea_dist ~ aotea_site$code,
                        permutations = n_perm,
                        parallel = n_cores)  

# You can't do pairwise comparisons in adonis2 but the pairwiseAdonis
# package allows this
aotea_pa_pw <- aotea_pa
aotea_pa_pw$site <- aotea_site$code

aotea_pw_adonis <- pairwise.adonis2(aotea_pa[,-274] ~ site,
                                    data = aotea_pa_pw,
                                    permutations = n_perm,
                                    parallel = n_cores)

# Test for homogeneity of variance (scatter)
aotea_mod <- betadisper(aotea_dist, aotea_site$code)
aotea_mod_perm <- permutest(aotea_mod, pairwise = TRUE, permutations = n_perm)
aotea_mod_HSD <- TukeyHSD(aotea_mod)
```

The plots below show the observed (red line) test statistic and the
distribution of the simulated values -- in both cases suggesting that
there is a strong location effect of site (in this case due to
successional differences). We can drill into this further by looking at
the `aotea_pw_adonis` object.

```{r testOutput, warning = FALSE, message = FALSE}
# permuted stats
aotea_perm_dfr <- data.frame(perm = c(permustats(aotea_anosim)$permutations,
                                      permustats(aotea_adonis)$permutations),
                             test = rep(c('ANOSIM', 'PERMANOVA'),
                                        each = 499))

# observed stat (for comparison)
aotea_stat_dfr <- data.frame(stat = c(permustats(aotea_anosim)$statistic, 
                                      permustats(aotea_adonis)$statistc),
                             test = c('ANOSIM', 'PERMANOVA'))

fig22 <- ggplot(aotea_perm_dfr) + 
  geom_histogram(aes(x = perm)) +
  geom_vline(data = aotea_stat_dfr, aes(xintercept = stat), col = "red") +
  facet_wrap(~test, scales = "free_x") + 
  labs (x = 'Permutation statistics', y = 'Frequency') + 
  theme_minimal()
```

```{r fig.cap = "ADD CAPTION", fig.dim = c(8, 4), echo = FALSE, message = FALSE}
fig22
```


```{r permuTablesOp, fig.cap = "ADD CAPTION", fig.dim = c(6,6), warning = FALSE, message = FALSE}
aotea_adonis_td <- tidy(aotea_adonis)

plot(aotea_mod, main = "")
```

As discussed in the main text, ecological community data can have strong
mean-variance relationships [@wartonModelbasedThinkingCommunity2015].
Model-based approaches to multivariate analysis are a direct response to
this issue. One way to address this problem is a transformation of the
data to down-weight abundant species (e.g. log-transform). Clarke et al
[-@clarkeDispersionbasedWeightingSpecies2006] describe a method that
individually weights species based on their departure from a Poisson
(mean = variance) distribution.

```{r invertDownWeight, message = FALSE, warning = FALSE, results = 'hide'}
# calculate invertebrate mean and variance abundance

# vegan::dispweight implements the method
inverts_dispw <- dispweight(inverts)

# calculate mean and variance
iv_var <- apply(inverts, 2, var) 
iv_mean <- apply(inverts, 2, mean)
iv_sig <- as.factor(ifelse(attr(inverts_dispw, "p") < 0.01, TRUE, FALSE))
iv_dfr <- data.frame(m = iv_mean, v = iv_var, signif = iv_sig)

# plot
fig24 <- ggplot(iv_dfr) + 
  geom_point(aes(x = m , y = v, size = m / v, colour = signif)) + 
  geom_abline(slope = 1, intercept = 0) + 
  scale_x_log10() + 
  scale_y_log10() + 
  labs(x = "Mean abundance",
       y = "Var. abundance",
       colour = "Depart from\nPoisson") +
  theme_bw()

# nMDS
invert_wgt_mds <- metaMDS(inverts_dispw, distance = 'bray',
                          autotransform = FALSE, trace = 1)

iv_mds_wgt_gg <- plot.mds.gg(invert_wgt_mds,
                             txt.x = -0.9,
                             txt.y = -0.8,
                             labels = TRUE)

fig25 <- (iv_mds_gg + iv_mds_wgt_gg) +
    plot_annotation(tag_level = "a")
```


```{r echo = FALSE, fig.cap = "Mean - variance relationship for Lee et al. invertebrate abundance data.", fig.dim = c(5,4)}
fig24
```

```{r echo = FALSE, fig.cap = "Unweighted ordination of Lee et al. invertebrate data (a). Abundance weighted ordination of Lee et al. invertebrate data.", fig.dim = c(8,4)}
fig25
```

## SIMPER and Indicator species

Finally, we might want to identify the species (or variable) that
characterise specific groups. One commonly employed method to so this is
SIMPER (for Brya-Curtis data). This method, however, tends to conflate
changes in species mean and variance across groups and so may pick out
the most variable (see Warton et al. 2012). We'll try it on the
Aotea vegetation data to look at what species might contribute to
differences between geographic locations.

```{r simperAotea}
# run analysis
simper_veg <- simper(aotea_pa, group = aotea_site$code)
```

The function provides a large amount of information that we need to sift
through (not printed out here), but we can see which species contribute
most to differences between groups. We need to use permutation to assess
these differences more robustly.

```{r simperPermAotea}

if (file.exists("./rds/aotea_simper_perm.rds")) { 
  aotea_mds <- readRDS("./rds/aotea_simper_perm.rds") } else {
  n_cores <- parallel::detectCores() - 1  
  n_perm <-19
  simper_perm_veg <- simper(aotea_pa,
                            group = aotea_site$code,
                            permutations = n_perm,
                            parallel = n_cores,
                            trace = FALSE)
  
  saveRDS(aotea_mds, "./rds/aotea_simper_perm.rds") 
  }

# summary(simper_perm_veg)
```

A different, and potentially more robust, approach is to use the
indicator analysis described by de Caceres and colleagues
[-@decaceresImprovingIndicatorSpecies2010;
-@decaceresAssociationsSpeciesGroups2009]. This method seeks to identify
'faithful' species - in other words, those species that if present
enable you to confidently determine the vegetation type (or types). The
`indicspecies` package implements this approach, building on the work of
Dufrêne and Legendre [-@dufreneSpeciesAssemblagesIndicator1997].

```{r indicSppAotea}
n_perm <- 99
aotea_indic <- multipatt(aotea_pa,
                         cluster = aotea_site$code,
                         control = how(nperm = n_perm))

# summarise, showing A and B for species with p <= .01
summary(aotea_indic, indvalcom = TRUE, alpha = 0.01)

```

Again, this function yields a wealth of information. We can see that of
the 273 species in the data, c. 140 are deemed to provide association
information (85 to 1 group). We can also see two parameters *A* and *B*.
The first of these is the probability that a site belongs to some group
given the presence of the species and *B* the probability of finding the
species given the site type. As the (vignette for
indicspecies)[<https://cran.r-project.org/web/packages/indicspecies/vignettes/indicspeciesTutorial.pdf>]
notes, there are potential problems here with the familywise error rate
so some correction (or caution) may be required.

If we want to hone in on indicator taxa for specific groups then we can
use the `indicators` function. For example, we could identify indicators
(here just pairs) for the community at the Awana ('AW') site (the
earliest in the succession). We can constrain so that *A* and *B* are
above some threshold.

```{r indicatorBootAwana}
# set verbose TRUE to turn on the output
awana_indicators <- indicators(aotea_pa, cluster = aotea_site$code,
                               group = "AW", At = 0.7, Bt = 0.3,
                               max.order = 2, verbose = FALSE)

summary(awana_indicators)
print(awana_indicators)
```

We can estimate confidence limits for these statistics.

```{r indicatorAwana}
n_boot <- 19
awana_indicators_boot <- indicators(aotea_pa,
                                    cluster = aotea_site$code,
                                    group = "AW", At = 0.7,
                                    Bt = 0.3,
                                    max.order = 2,
                                    nboot.ci = n_boot,
                                    verbose = FALSE)

summary(awana_indicators_boot)
print(awana_indicators_boot$A) # inspect the A values
```

# References
